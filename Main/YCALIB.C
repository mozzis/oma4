/* -----------------------------------------------------------------------
/
/  YCALIB.C
/
/  Author: Morris Maynard October 1993
/  Intensity calibration method supplied by David Baker
/  Copyright (c) 1993,  EG&G Instruments Inc.
/
/  $Header:
/  $Log:
/
*/

/*                                                                          *
 * This module allows the user to calibrate intensity data into radiometric *
 * units.  This is done by generating a correction curve for each track of  *
 * the CCD which, when multiplied by the raw detector data, will convert it *
 * from counts into some radiometric unit.  The correction curve set is     *
 * generated using data from a standard calibrated lamp.  The lamp supplier *
 * provides an ASCII file which gives the absolute intensity of the lamp at *
 * a number of wavelengths.  This module refers to this data as "Lamp Data".*
 * The lamp data are read in and used to define knots for the spline fit    *
 * functions in spline-3.c.  A curve set must also be generated by acquir-  *
 * ing a frame from the standard lamp.  This curve set is referred to as    *
 * the "Lamp Curve".  The correction curve can then be calculated as:       *
 *       Ú           ¿   Ú     ¿                                            *
 *       ³ Lamp Data ³   ³  1  ³  The exposure time is used to provide the  *
 *   CC =³ ----------³ * ³ --- ³  data in units of (e.g.) uW/nm/cm2/sec     *
 *       ³ Lamp Curve³   ³ ET. ³  depending on the units of the Lamp Data.  *
 *       À           Ù   À     Ù                                            *
 *                                                                          *
 * Lamp Data points in between those supplied by the manufacturer are int-  *
 * erpolated from the spline fit function.                                  *
 *                                                                          *
 * The correction curve set is referred to as "Correx Curve", or sometimes  *
 * as "Corr Curve".  The correction curve can be applied to subsequent data *
 * acquisitions by using the formula:                                       *
 *                                                                          *
 *                     Raw Data                                             *
 *   Calibrated data = --------  * CC                                       *
 *                        ET                                                *
 *                                                                          *
 * The calibrated data are then also in the units of the original lamp data.*
 * This last calculation can be done in two steps on the math menu.  It can *
 * also be done in one step here using the Apply To and Apply fields.  The  *
 * curve set to be calibrated is referred to here as the "Real Curve" set.  *
*/

#include <string.h>       // strupr(), strcpy()
#include <stdlib.h>       // strtol
#include <conio.h>

#include "ycalib.h"
#include "curvdraw.h"
#include "points.h"
#include "doplot.h"       // create_plotbox()
#include "spline-3.h"     // point_interp(), etc
#include "helpindx.h"     // YCALIB_HBASE,  help file index
#include "cursor.h"       // ActiveWindow, CursorStatus -- globals
#include "device.h"
#include "omaform.h"      // GraphWindow
#include "di_util.h"      // ParsePathAndName()
#include "curvedir.h"     // SearchNextNamePath()
#include "ksindex.h"    
#include "macrecor.h"   
#include "multi.h"      
#include "plotbox.h"
#include "syserror.h"     // ERROR_ALLOC_MEM
#include "omaerror.h"
#include "crventry.h"
#include "crvheadr.h"
#include "forms.h"
#include "formwind.h"
#include "splitfrm.h"
#include "omazoom.h"      // cursor_loc
#include "fkeyfunc.h"
#include "formtabs.h"
#include "oma4driv.h"      // GetParam(ET)
#include "fileform.h"     // is_special_name()
#include "mathops.h"      // OP_BLOCK
#include "tempdata.h"     // CreateTempFileBlk, etc.

#ifdef STATIC
   #define PRIVATE static
#else
   #define PRIVATE
#endif

#define KNOT_MARKER_HEIGHT 400     // number is from testing on VGA -
                                   // actually selects 356

// TRUE iff in ycalib mode
static BOOLEAN ycalib_mode = FALSE;

// for specifying what to draw in each of the z-axis positions of the
// ycalib plot box.  Each is a one bit flag.
enum { lamp_curve = 1, correx_curve = 2, data_curve = 4 } curve_kinds;

// things to allow selection and display of lamp units
enum { counts, counts_sec, uwatts_per_cm2 } lamp_units_kinds; 
static char unit_designators[] = { 0, 1, 0x10 };
static enum lamp_units_kinds lamp_units = counts;
static char * units_options[] = {
  "Counts",
  "Counts/sec",
  "æW/nm/cm2",
};

// for specifying what to do with a Lamp Data file
enum {
  read_lamp_file,
  save_lamp_file,
} lampfile_op;
static enum lampfile_op lampfile_op_flag;
static char * file_action[] = {
  "Load",
  "Save",
};

// x-y values for a knot and a point
static int total_pairs;
static float X_knot;
static float Y_knot;
static float Z_param;

// dummy variables for select fields
static int add_pair_dummy = 0;
static int del_pair_dummy = 0;
static int gen_corr_dummy = 0;
static int app_corr_dummy = 0;

/* name of ASCII or special format Lamp Data file */
static char lamp_file_spec[DOSFILESIZE + DOSPATHSIZE + 1] = "";

OP_BLOCK Lamp = { "", MAXFLOAT, -1, 0, 0, FALSE }, /* for lamp curve */
         Corr = { "", MAXFLOAT, -1, 0, 0, FALSE }, /* for correction curve */
         Real = { "", MAXFLOAT, -1, 0, 0, FALSE }; /* for data to calibrate */

enum DATAREGISTRY_ACCESS
{
  DGROUP_DO_STRINGS = 1, DGROUP_TOGGLE, DGROUP_CODE, DGROUP_DATA, DGROUP_FORM
};

// registries for the forms

static DATA DO_STRING_Reg[] =
{
  { "Correction Curve Set", 0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  0
  { "Curves",               0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  1
  { "Save",                 0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  2
  { "Load",                 0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  3
  { "Lamp Data File",       0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  4
  { "Lamp Curve Set",       0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  5
  { "Correction Curve Set", 0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  6
  { "Curve Number",         0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  7
  { "Add   ",               0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  8
  { "Delete",               0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  9
  { "Wavelen.   Value",     0, DATATYP_STRING, DATAATTR_PTR, 0 },  // 10
  { "Apply to ",            0, DATATYP_STRING, DATAATTR_PTR, 0 },  // 11
  { "Lamp values",          0, DATATYP_STRING, DATAATTR_PTR, 0 },  // 12
  { "Create",               0, DATATYP_STRING, DATAATTR_PTR, 0 },  // 13
  { "Units",                0, DATATYP_STRING, DATAATTR_PTR, 0 },  // 14
};

// toggle stuff for toggle registry
static DATA TOGGLE_Reg[] =
{
  {file_action,   0, DATATYP_STRING_ARRAY, DATAATTR_PTR, 0 }, 
  {units_options, 0, DATATYP_STRING_ARRAY, DATAATTR_PTR, 0 } 
};

PRIVATE BOOLEAN ycalib_form_init(int dummy);
PRIVATE BOOLEAN ycalib_form_exit(void);
PRIVATE BOOLEAN yknots_form_init(int index);
PRIVATE int verify_filespec  (void * field_data, char * field_string);
PRIVATE int verify_lamp_curve(void * field_data, char * field_string);
PRIVATE int verify_corr_curve(void * field_data, char * field_string);
PRIVATE int verify_real_curve(void * field_data, char * field_string);
PRIVATE int do_lampfile_op   (void * field_data, char * field_string);
PRIVATE int gen_correx_curves(void * field_data, char * field_string);
PRIVATE int ycal_data_curves (void * field_data, char * field_string);
PRIVATE int edit_ycalib_pair (void * field_data, char * field_string);
PRIVATE int add_ycalib_pair(void * field_data, char * field_string);
PRIVATE int delete_ycalib_pair(void * field_data, char * field_string);

PRIVATE ERR_OMA get_lampcurve_data(CURVEDIR *, SHORT, USHORT, USHORT,
                                          float *, float *, CHAR, SHORT*);
static EXEC_DATA CODE_Reg[] =
{
/* 0*/ { CAST_CHR2INT ycalib_form_init,   0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/* 1*/ { ycalib_form_exit,                0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/* 2*/ { CAST_CHR2INT yknots_form_init,   0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/* 3*/ { CAST_CHR2INT NULL,               0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/* 4*/ { CAST_CHR2INT add_ycalib_pair,    0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/* 5*/ { CAST_CHR2INT delete_ycalib_pair, 0, DATATYP_CODE, DATAATTR_PTR, 0 },     
//scroll_... are declared in forms.h
/* 6*/ { CAST_CHR2INT scroll_entry_field, 0, DATATYP_CODE, DATAATTR_PTR, 0 },
/* 7*/ { CAST_CHR2INT scroll_up_field,    0, DATATYP_CODE, DATAATTR_PTR, 0 },
/* 8*/ { CAST_CHR2INT scroll_down_field,  0, DATATYP_CODE, DATAATTR_PTR, 0 },
/* 9*/ { CAST_CHR2INT refresh_scroll_only,0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/*10*/ { CAST_CHR2INT do_lampfile_op,     0, DATATYP_CODE, DATAATTR_PTR, 0 },     
/*11*/ { CAST_CHR2INT verify_filespec,    0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*12*/ { CAST_CHR2INT verify_lamp_curve,  0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*13*/ { CAST_CHR2INT verify_real_curve,  0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*14*/ { CAST_CHR2INT gen_correx_curves,  0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*15*/ { CAST_CHR2INT ycal_data_curves,   0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*16*/ { CAST_CHR2INT edit_ycalib_pair,   0, DATATYP_CODE, DATAATTR_PTR, 0 },  
/*17*/ { CAST_CHR2INT verify_corr_curve,  0, DATATYP_CODE, DATAATTR_PTR, 0 },  
};

static DATA DATA_Reg[] = {
  { &total_pairs,      0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  0
  { &X_knot,           0, DATATYP_FLOAT,  DATAATTR_PTR, 0 },  //  1
  { &Y_knot,           0, DATATYP_FLOAT,  DATAATTR_PTR, 0 },  //  2
  { &add_pair_dummy,   0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  3
  { &del_pair_dummy,   0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  4
  { NULL,              0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  5
  { &lamp_units,       0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  6
  { lamp_file_spec,    0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  7
  { Lamp.Spec,         0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  8
  { Corr.Spec,         0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  9
  { &lampfile_op_flag, 0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  10
  { &Lamp.Count,       0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  11
  { Real.Spec,         0, DATATYP_STRING, DATAATTR_PTR, 0 },  //  12
  { &gen_corr_dummy,   0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  13
  { &app_corr_dummy,   0, DATATYP_INT,    DATAATTR_PTR, 0 },  //  14
};

// declare form now, definition later
static FORM yknots_form;

static DATA FORM_Reg[] = {
  { &yknots_form,  0, DATATYP_VOID, DATAATTR_PTR, 0 },  
  };

// fields are organized in five groups by column
#define COL_A 2
#define COL_B 30
#define COL_C 40
#define COL_D 49
#define COL_E 57

// names for the form fields
enum ycalib_field_names {
   LBL_LAMP_DATA,
   LBL_LAMP_UNITS,
   LBL_LAMP_CURVE,
   LBL_LAMP_COUNT,
   LBL_CORR_DATA, 
   LBL_REAL_DATA, 
   LBL_KNOTS,
   LBL_X_Y,
   FLD_LAMP_DATA,
   FLD_LAMP_UNITS,
   FLD_LAMP_ACT,
   FLD_LAMP_CURVE,
   FLD_LAMP_COUNT,
   FLD_CORR_CURVE,
   FLD_CORR_CREATE,
   FLD_REAL_CURVE,
   FLD_REAL_APPLY,
   FLD_KNOTS,
   FLD_ADDKNOT,
   FLD_DELKNOT,
   FLD_KNOTSC,
};

static FIELD ycalib_fields[] =
{
  label_field(LBL_LAMP_DATA,           
    DGROUP_DO_STRINGS, 4,
    2, COL_A, 14),

  label_field(LBL_LAMP_UNITS,           
    DGROUP_DO_STRINGS, 14,
    1, COL_B, 5),

  label_field(LBL_LAMP_CURVE,           
    DGROUP_DO_STRINGS, 5,
    4, COL_A, 14),

  label_field(LBL_LAMP_COUNT,           
    DGROUP_DO_STRINGS, 1,
    4, COL_C, 6),

  label_field(LBL_CORR_DATA,           
    DGROUP_DO_STRINGS, 0,
    6, COL_A, 20),

  label_field(LBL_REAL_DATA,           
    DGROUP_DO_STRINGS, 11,
    8, COL_A, 9),

  label_field(LBL_KNOTS,          
    DGROUP_DO_STRINGS, 12,
    1, COL_E + 4, 11),

  label_field(LBL_X_Y,            
    DGROUP_DO_STRINGS, 10,         /* "Wavelen.  Value" */
    2, COL_E, 16),

  field_set(FLD_LAMP_DATA,        
    FLDTYP_STRING,
    FLDATTR_REV_VID,
    KSI_YCAL_LAMP_DATA,
    YCALFORM_HBASE + 0,
    DGROUP_DATA, 7,               /* lamp_file_spec */
    0, 0,                         
    DGROUP_CODE, 11,              /* verify_filespec */
    DOSFILESIZE + DOSPATHSIZE + 1, 0,
    3, COL_A, 35,
    EXIT, FLD_LAMP_DATA, FLD_REAL_CURVE, FLD_LAMP_CURVE,
    FLD_LAMP_DATA, FLD_LAMP_ACT, FLD_KNOTSC, FLD_LAMP_ACT),

  field_set(FLD_LAMP_UNITS,
    FLDTYP_TOGGLE,
    FLDATTR_REV_VID,
    KSI_YCAL_LAMP_UNITS,
    YCALFORM_HBASE + 1,
    DGROUP_DATA,   6,             /* lamp_units */
    DGROUP_TOGGLE, 1,             /* units_options */
    0, 0,
    0, 3,                         /* 3 option toggle field */
    1, COL_C, 10,
    EXIT, FLD_LAMP_UNITS, FLD_REAL_APPLY, FLD_LAMP_ACT,
    FLD_LAMP_DATA, FLD_LAMP_DATA, FLD_LAMP_DATA, FLD_LAMP_DATA),

  field_set(FLD_LAMP_ACT,
    FLDTYP_TOGGLE,
    FLDATTR_REV_VID,
    KSI_YCAL_LAMP_ACT,
    YCALFORM_HBASE + 2,
    DGROUP_DATA,   10,            /* lampfile_op_flag */
    DGROUP_TOGGLE, 0,             /* lampfile_action[] */
    DGROUP_CODE,   10,            /* do_lampfile_op() */
    0, 2,                         /* 2 option toggle field */
    3, COL_C, 4,
    EXIT, FLD_LAMP_ACT, FLD_LAMP_UNITS, FLD_CORR_CREATE,
    FLD_LAMP_DATA, FLD_DELKNOT, FLD_LAMP_DATA, FLD_ADDKNOT),

  field_set(FLD_LAMP_CURVE,        
    FLDTYP_STRING,
    FLDATTR_REV_VID,
    KSI_YCAL_LAMP_CURVE,
    YCALFORM_HBASE + 3,
    DGROUP_DATA, 8,               /* Lamp.Spec */
    0, 0,                         
    DGROUP_CODE, 12,              /* verify_lamp_curve */
    DOSFILESIZE + DOSPATHSIZE + 1, 0,
    5, COL_A, 35,
    EXIT, FLD_LAMP_CURVE, FLD_LAMP_DATA, FLD_CORR_CURVE,
    FLD_LAMP_DATA, FLD_DELKNOT, FLD_KNOTSC, FLD_DELKNOT),

  field_set(FLD_LAMP_COUNT,       
    FLDTYP_UNS_INT,
    FLDATTR_DISPLAY_ONLY | FLDATTR_RJ,
    KSI_NO_INDEX,
    0,
    DGROUP_DATA, 11,              /* Lamp.Count (Count) */
    0, 0,
    0, 0,
    0, 0,
    5, COL_C, 5,
    FLD_CORR_CURVE, FLD_CORR_CURVE, FLD_LAMP_COUNT, FLD_LAMP_COUNT,
    FLD_LAMP_COUNT, FLD_LAMP_COUNT, FLD_LAMP_COUNT, FLD_LAMP_COUNT),

  field_set(FLD_CORR_CURVE,        
    FLDTYP_STRING,
    FLDATTR_REV_VID,
    KSI_YCAL_CORR_CURVE,
    YCALFORM_HBASE + 4,
    DGROUP_DATA, 9,               /* Corr.Spec */
    0, 0,                         
    DGROUP_CODE, 17,              /* verify_corr_curve */
    DOSFILESIZE + DOSPATHSIZE + 1, 0,
    7, COL_A, 35,
    EXIT, FLD_CORR_CURVE, FLD_LAMP_CURVE, FLD_REAL_CURVE,
    FLD_LAMP_DATA, FLD_DELKNOT, FLD_KNOTSC, FLD_CORR_CREATE),

  field_set(FLD_CORR_CREATE,
    FLDTYP_SELECT,
    FLDATTR_REV_VID | FLDATTR_NO_OVERFLOW_CHAR,
    KSI_YCAL_CORR_CREATE,
    YCALFORM_HBASE + 5,
    DGROUP_DATA, 13,              /* gen_corr_dummy */
    DGROUP_DO_STRINGS, 13,        /* "Create" */
    DGROUP_CODE, 14,              /* gen_correx_curves() */
    1, 0,                         /* match value, dummy */
    7, COL_C, 6,
    EXIT, FLD_CORR_CREATE, FLD_LAMP_ACT, FLD_REAL_APPLY,
    FLD_KNOTS, FLD_KNOTS, FLD_CORR_CURVE, FLD_CORR_CURVE),

  field_set(FLD_REAL_CURVE,        
    FLDTYP_STRING,
    FLDATTR_REV_VID,
    KSI_YCAL_REAL_CURVE,
    YCALFORM_HBASE + 6,
    DGROUP_DATA, 12,              /* Real.Spec */
    0, 0,                         
    DGROUP_CODE, 13,              /* verify_real_curve */
    DOSFILESIZE + DOSPATHSIZE + 1, 0,
    9, COL_A, 35,
    EXIT, FLD_REAL_CURVE, FLD_CORR_CURVE, FLD_LAMP_DATA,
    FLD_LAMP_DATA, FLD_DELKNOT, FLD_KNOTSC, FLD_REAL_APPLY),

  field_set(FLD_REAL_APPLY,
    FLDTYP_SELECT,
    FLDATTR_REV_VID | FLDATTR_NO_OVERFLOW_CHAR,
    KSI_YCAL_REAL_APPLY,
    YCALFORM_HBASE + 7,
    DGROUP_DATA, 14,              /* app_corr_dummy */
    DGROUP_DO_STRINGS, 11,        /* "Apply" */
    DGROUP_CODE, 15,              /* ycal_data_curves() */
    1, 0,                         /* match value, dummy */
    9, COL_C, 5,
    EXIT, FLD_REAL_APPLY, FLD_CORR_CREATE, FLD_LAMP_UNITS,
    FLD_KNOTS, FLD_KNOTS, FLD_REAL_CURVE, FLD_KNOTSC),

  field_set(FLD_KNOTS,            
    FLDTYP_UNS_INT,
    FLDATTR_DISPLAY_ONLY | FLDATTR_RJ,
    KSI_NO_INDEX,
    0,
    DGROUP_DATA, 0,               /* total knots */
    0, 0,
    0, 0,
    0, 0,
    1, COL_E, 3,
    FLD_ADDKNOT, FLD_ADDKNOT, FLD_KNOTS, FLD_KNOTS,
    FLD_KNOTS, FLD_KNOTS, FLD_KNOTS, FLD_KNOTS),

  field_set(FLD_ADDKNOT,          
    FLDTYP_SELECT,
    FLDATTR_REV_VID | FLDATTR_NO_OVERFLOW_CHAR,
    KSI_YCAL_ADDKNOT,
    YCALFORM_HBASE + 8,
    DGROUP_DATA, 3,               /* add_pair_dummy */
    DGROUP_DO_STRINGS, 8,         /* "Select" */
    DGROUP_CODE, 4,               /* add_ycalib_pair() */
    1, 0,                         /* match value, dummy */
    3, COL_D, 6,
    EXIT, FLD_KNOTSC, FLD_DELKNOT, FLD_DELKNOT,
    FLD_LAMP_DATA, FLD_KNOTSC, FLD_LAMP_ACT, FLD_KNOTSC),

  field_set(FLD_DELKNOT,          
    FLDTYP_SELECT,
    FLDATTR_REV_VID | FLDATTR_NO_OVERFLOW_CHAR,
    KSI_YCAL_DELKNOT,
    YCALFORM_HBASE + 9, 
    DGROUP_DATA, 4,               /* del_pair_dummy */
    DGROUP_DO_STRINGS, 9,         /* "Delete" */
    DGROUP_CODE, 5,               /* delete_ycalib_pair() */
    1, 0,                         /* match value, dummy */
    5, COL_D, 6,
    EXIT, FLD_DELKNOT, FLD_ADDKNOT, FLD_ADDKNOT,
    FLD_LAMP_DATA, FLD_KNOTSC, FLD_LAMP_CURVE, FLD_KNOTSC),

  field_set(FLD_KNOTSC,           
    FLDTYP_FORM,
    FLDATTR_NONE,
    KSI_NO_INDEX,
    0, 
    DGROUP_FORM, 0,               /* scrolling knot form */
    0, 0,
    0, 0,
    0, 0,
    3, COL_E, 1,
    EXIT, FLD_KNOTSC, FLD_DELKNOT, FLD_ADDKNOT,
    FLD_ADDKNOT, FLD_DELKNOT, FLD_DELKNOT, FLD_LAMP_DATA),

}; /* end of ycalib_fields[] initialization */

static FORM YCalibForm = {                   
   0, 0,
   FORMATTR_BORDER | FORMATTR_FIRST_CHAR_ERASE | FORMATTR_VISIBLE |
   FORMATTR_FULLWIDTH,    
   0, 0, 0,
   2, 0, 11, 80,
   0, 0,
  { DGROUP_CODE, 0 },       // init_function : ycalib_form_init()
  { DGROUP_CODE, 1 },       // exit_function   ycalib_form_exit()
   COLORS_DEFAULT, 0, 0, 0, 0,
   sizeof(ycalib_fields) / sizeof(FIELD),
   ycalib_fields,
   KSI_YCAL_FORM,
   0, DO_STRING_Reg, TOGGLE_Reg, (DATA *)CODE_Reg, DATA_Reg, FORM_Reg
};

// scrolling form for displaying knot X,Y locations

enum yknots_form_field_names
{ FLD_KNOT_ENTRY,
  FLD_REF_ONLY,
  FLD_KNOT_UP,
  FLD_KNOT_DN,
  FLD_XKNOT_SCR,
  FLD_YKNOT_SCR
};

static FIELD yknots_form_fields[] = {

  // 0  logic field for scrolling form entry
  field_set(FLD_KNOT_ENTRY,
    FLDTYP_LOGIC,
    FLDATTR_NONE,
    KSI_NO_INDEX,
    0, 
    DGROUP_CODE, 6,     /*  scroll_entry_field() from forms.h */
    0, 0, 0, 0, 0, 0,
    1, 0, 1,
    EXIT, FLD_REF_ONLY, FLD_KNOT_ENTRY, FLD_KNOT_ENTRY,
    FLD_KNOT_ENTRY, FLD_REF_ONLY, FLD_KNOT_ENTRY, FLD_KNOT_ENTRY),
 
    /* 1  logic field for checking refresh only, bail out if only refreshing */
  field_set(FLD_REF_ONLY,
    FLDTYP_LOGIC,
    FLDATTR_NONE,
    KSI_NO_INDEX, 0, 
    DGROUP_CODE, 9,      /* refresh_scroll_only() */
    0, 0,
    0, 0,
    0, 0,
    1, 2, 1,
    FLD_XKNOT_SCR, EXIT, FLD_XKNOT_SCR, FLD_XKNOT_SCR,
    FLD_XKNOT_SCR, FLD_XKNOT_SCR, FLD_XKNOT_SCR, FLD_XKNOT_SCR),

  /* 2  logic field for scrolling up */
  field_set(FLD_KNOT_UP,
    FLDTYP_LOGIC,
    FLDATTR_NONE,
    KSI_NO_INDEX,
    0, 
    DGROUP_CODE, 7,          /* scroll_up_field() from forms.h */
    0, 0,
    0, 0,
    0, 0,
    1, 4, 1,
    EXIT, FLD_XKNOT_SCR, FLD_KNOT_UP, FLD_XKNOT_SCR,
    FLD_KNOT_ENTRY, FLD_KNOT_DN, FLD_REF_ONLY, FLD_KNOT_DN),
  
  /* 3  logic field for scrolling down */
  field_set(FLD_KNOT_DN,
    FLDTYP_LOGIC,
    FLDATTR_NONE,
    KSI_NO_INDEX,
    0, 
    DGROUP_CODE, 8,          /* scroll_down_field() from forms.h */
    0, 0,
    0, 0,
    0, 0,
    1, 6, 1,
    EXIT, FLD_XKNOT_SCR, FLD_KNOT_DN, FLD_XKNOT_SCR,
    FLD_KNOT_ENTRY, FLD_XKNOT_SCR, FLD_KNOT_UP, FLD_XKNOT_SCR),

  /* 4  The float X-value of each knot */
  field_set(FLD_XKNOT_SCR,
    FLDTYP_STD_FLOAT,
    FLDATTR_RJ | FLDATTR_REV_VID,
    KSI_YCAL_XKNOT_SCR,
    YCALFORM_HBASE + 10,
    DGROUP_DATA, 1,          /* float X_knot */
    0, 0,
    DGROUP_CODE, 16,         /* edit_ycalib_pair() */
    2, 0,
    0, 0, 7,
    EXIT, FLD_XKNOT_SCR, FLD_KNOT_UP, FLD_KNOT_DN,
    EXIT, FORM_EXIT_DN,  FORM_EXIT_DN, FLD_YKNOT_SCR),

  /* 5  The float Y value of each knot */
  field_set(FLD_YKNOT_SCR,
    FLDTYP_STD_FLOAT,
    FLDATTR_REV_VID,
    KSI_YCAL_YKNOT_SCR,
    YCALFORM_HBASE + 11,
    DGROUP_DATA, 2,          /* float Y_knot */
    0, 0,
    DGROUP_CODE, 16,         /* edit_ycalib_pair() */
    5, 0,
    0, 9, 10,
    EXIT, FLD_YKNOT_SCR, FLD_KNOT_UP, FLD_KNOT_DN,
    EXIT, FORM_EXIT_DN, FLD_XKNOT_SCR, FORM_EXIT_DN)
};

static FORM yknots_form = {
   0, 0,
   FORMATTR_SCROLLING | FORMATTR_FIRST_CHAR_ERASE | FORMATTR_VISIBLE,
   0, 0, 0,
   3, COL_E, 7, 20,
   0, 0,
  { DGROUP_CODE, 2 },         /* yknots_form_init() */
  { 0, 0 }, COLORS_DEFAULT,
   0, 0, 0, 0,
   sizeof(yknots_form_fields) / sizeof(FIELD),
   yknots_form_fields,
   KSI_YKNOTS_FORM,
   0, DO_STRING_Reg, TOGGLE_Reg, (DATA *)CODE_Reg, DATA_Reg, 0
};


// Invoked as a form initialization function.  Initialize form variables.
// Returns zero iff error, else returns one.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN ycalib_form_init(int dummy_not_used)
{
  InitSplitForm(&YCalibForm, &ycalib_mode, NULL);

  FKeyItems[1].Control |= MENUITEM_INACTIVE; 
  ShowFKeys(& FKey);

  Z_param = CursorStatus[ActiveWindow].Z;
  total_pairs = current_knots();

  if (Lamp.BlkIndex == 0xFFFF)
    {
    Lamp.BlkIndex = CursorStatus[ActiveWindow].EntryIndex;
      if (Lamp.BlkIndex != 0xFFFF)
        {
        Lamp.Count = MainCurveDir.Entries[Lamp.BlkIndex].count;
        strcpy(Lamp.Spec, MainCurveDir.Entries[Lamp.BlkIndex].path);
        strcat(Lamp.Spec, MainCurveDir.Entries[Lamp.BlkIndex].name);
        }
    }
  return FALSE;               
}

// put form and plot box on screen, interract with user to do baseline
// subtract function, restore screen when done.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN ycalib_form_exit(void)
{
  ExitSplitForm(&ycalib_mode);
  FKeyItems[1].Control &= ~MENUITEM_INACTIVE; 
  ShowFKeys(& FKey);
  return FALSE;
}

// return TRUE iff spline knots are being manually specified by the user
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN ycalib_active(void) { return ycalib_mode; }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int file_error(ERR_OMA err, char * filespec)
{
  error(err, filespec);
  return FIELD_VALIDATE_WARNING;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int verify_filespec(void * field_data, char * field_string)
{
  char check_file_spec[DOSFILESIZE + DOSPATHSIZE + 1] = "";

  if (ParseFileName(check_file_spec, field_data) != 2)
    return(file_error(ERROR_BAD_FILENAME, field_data));

  strcpy(field_data, check_file_spec);
  return FIELD_VALIDATE_SUCCESS;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN all_spaces(char * string)
{
  USHORT i;
  for (i = 0; i < strlen(string); i++)
    if (string[i] != ' ')
      return FALSE;

  return TRUE;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SHORT verify_corr_curve(void * field_data, char * field_string)
{
  char check_path[DOSPATHSIZE + 1] = "";
  char check_name[DOSFILESIZE + 1] = "";

  if (!field_data || field_data == "" || all_spaces(field_data))
    return -1;

  if(is_special_name(field_data))
    {
    check_path[0] = 0;
    strcpy(check_name, field_data);
    }
  else if (ParsePathAndName(check_path, check_name, field_data) != 2)
    return file_error(ERROR_BAD_FILENAME, field_data);

  strcpy(field_data, check_path);
  strcat(field_data, check_name);
  return FIELD_VALIDATE_SUCCESS;
}

// ensure that a given curve set is specified correctly and is present 
// returns the entry number of the curveset,  -1 if not found.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SHORT check_curve_spec(char * filespec, int CurveNum)
{
  char check_path[DOSPATHSIZE + 1] = "";
  char check_name[DOSFILESIZE + 1] = "";

  if (!filespec || filespec == "" || all_spaces(filespec))
    return -1;

  if(is_special_name(filespec))
    {
    check_path[0] = 0;
    strcpy(check_name, filespec);
    }
  else if (ParsePathAndName(check_path, check_name, filespec) != 2)
    {
    file_error(ERROR_BAD_FILENAME, filespec);
    return -1;
    }
  strcpy(filespec, check_path);
  strcat(filespec, check_name);

  return SearchNextNamePath(check_name, check_path, &MainCurveDir, CurveNum);
}

PRIVATE BOOLEAN isYCalibForm(void)
{
  FORM * thisForm = CurrentForm();
  return (thisForm == &YCalibForm || thisForm == &yknots_form);
}

// Check_curve_spec for lamp curve - field action routine
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int verify_lamp_curve(void * field_data, char * field_string)
{
  SHORT Entry = check_curve_spec(field_data, 0);
  
  if (Entry == -1)
    return(file_error(ERROR_CURVESET_NOT_FOUND, field_data));

  Lamp.BlkIndex = Entry;
  Lamp.Count = MainCurveDir.Entries[Entry].count;
  if (isYCalibForm())
    {
    display_random_field(&YCalibForm, FLD_LAMP_CURVE);
    display_random_field(&YCalibForm, FLD_LAMP_COUNT);
    }

  return FIELD_VALIDATE_SUCCESS;
}

// Check curve set for data curve
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int verify_real_curve(void * field_data, char * field_string)
{
  SHORT Entry = check_curve_spec(field_data, 0);

  if (Entry == -1)
    return(file_error(ERROR_CURVESET_NOT_FOUND, field_data));

  Real.BlkIndex = Entry;
  Real.Count = MainCurveDir.Entries[Entry].count;
  display_random_field(&YCalibForm, FLD_REAL_CURVE);
  return FIELD_VALIDATE_SUCCESS;
}

// get data function for use by generic_plot().  Return the value of the
// lamp curve in x_val, y_val.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE ERR_OMA get_lamp_data(CURVEDIR *CurveDir,
                                     SHORT EntryIndex,
                                     USHORT CurveIndex , USHORT index,
                                     float * x_val, void * y_val,
                                     CHAR DataType, SHORT *PrefBuf)
{
  // first put the data point of the real curve in x_val, y_val
  ERR_OMA err = GetDataPoint(CurveDir, EntryIndex, CurveIndex,
                                    index, x_val, y_val, DataType,
                                    PrefBuf);

  if(!err)       // put the y value of the lamp data in y_val
    *(FLOAT *)y_val = point_interp(*x_val);

  return err;
}

// Redraw the ycalib plot box. the whole thing : axes, labels, and all
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int ycalib_redraw(void * field_data, char * field_string)
{
  erase_mouse_cursor();               
  MouseCursorEnable(FALSE);
  create_plotbox(&Plots[CAL_PLOTBOX]);
  plot_curves(& MainCurveDir, & Plots[CAL_PLOTBOX], CAL_PLOTBOX);

  MouseCursorEnable(TRUE);          

  if (active_locus == LOCUS_APPLICATION)    
    CDisplayCursor(deviceHandle(), cursor_loc);

  return FIELD_VALIDATE_SUCCESS;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN get_header_string(FILE * file, char * test_string)
{
  char temp[40];
  
  if ((fscanf(file, "%s", temp) != 1) || (strcmp(test_string, temp)))
    {
    fclose(file);
    return TRUE;
    }
  return FALSE;
}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int do_lampfile_op(void * field_data, char * field_string)
{
  int i;
  FILE * lfile;
  BOOLEAN YCalibVisible = isYCalibForm();

  if (lampfile_op_flag == read_lamp_file)
    {
    FLOAT X, Y;
    char temp[40];
    char * DelKnotsMsg[] = {
      "This action will delete the current lamp data",
      "list.  Continue?",
      NULL,
      };

    if ((lfile = fopen(lamp_file_spec, "rt")) == NULL)
      return(file_error(ERROR_OPEN, lamp_file_spec));

    if (get_header_string(lfile, "LAMP"))
      return FIELD_VALIDATE_WARNING;

    if (get_header_string(lfile, "DATA"))
      return FIELD_VALIDATE_WARNING;

    if (get_header_string(lfile, "LAMP"))
      return FIELD_VALIDATE_WARNING;

    if (get_header_string(lfile, "UNITS"))
      return FIELD_VALIDATE_WARNING;

    if (total_pairs)
      {
      if (yes_no_choice_window(DelKnotsMsg, 0, COLORS_MESSAGE) != YES)
        {
        fclose(lfile);
        return FIELD_VALIDATE_SUCCESS;
        }
      delete_all_knots();
      total_pairs = 0;
      }

    if (fscanf(lfile, "%s", temp) != 1)
      {
      fclose(lfile);
      return(file_error(ERROR_READ, lamp_file_spec));
      }

    lamp_units = (int)strtol(temp, NULL, 10);
    if (lamp_units > 2)
      lamp_units = 2;

    if (YCalibVisible)
      display_random_field(&YCalibForm, FLD_LAMP_UNITS);

    do
      {
      if (fscanf(lfile, "%f \t %f", &X, &Y) != 2)
        break;
      add_knot(X, Y);
      total_pairs = current_knots();
      if (YCalibVisible)
        display_random_field(&YCalibForm, FLD_KNOTS);
      }
    while (!feof(lfile));
    fclose(lfile);
    if (YCalibVisible)
      redraw_scroll_form(&yknots_form, total_pairs, FLD_XKNOT_SCR);

    if (YCalibVisible)
      {
      display_random_field(&YCalibForm, FLD_KNOTS);
      ycalib_redraw(NULL, NULL);
      }
    return FIELD_VALIDATE_SUCCESS;
    }
  else   /* save file */
    {
    if ((lfile = fopen(lamp_file_spec, "wt")) == NULL)
      return(file_error(ERROR_OPEN, lamp_file_spec));

    if (fprintf(lfile, "LAMP DATA\n"
                       "LAMP UNITS %d\n", lamp_units) < 0)
      {
      fclose(lfile);
      return(file_error(ERROR_WRITE, lamp_file_spec));
      }
    for(i = 0; i < total_pairs; i ++)
      {
      if (fprintf(lfile, "%f \t %f \n", knot_x_val(i), knot_y_val(i)) < 0)
        {
        fclose(lfile);
        return(file_error(ERROR_WRITE, lamp_file_spec));
        }
      }
    fclose(lfile);
    }
  return FIELD_VALIDATE_SUCCESS;
}

// Routine for macro language to load lamp data file
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN LoadLampFile(char * Name)
{
  BOOLEAN retval = FALSE;
  
  lampfile_op_flag = read_lamp_file;
  strcpy(lamp_file_spec, Name);
  if (do_lampfile_op(Name, Name) == FIELD_VALIDATE_SUCCESS)
    retval = TRUE;

  return retval;
}

// Routine for macro language to save lamp data file
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN SaveLampFile(char * Name)
{
  BOOLEAN retval = FALSE;
  
  lampfile_op_flag = save_lamp_file;
  strcpy(lamp_file_spec, Name);
  if (do_lampfile_op(Name, Name) == FIELD_VALIDATE_SUCCESS)
    retval = TRUE;

  return retval;
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SHORT CheckDestBlock(OP_BLOCK *Blk, CHAR * Name, CHAR * Path)
{
  /* expand the file block name and check to see if it is not a directory */
  /* 'special' files have no path */
  if(is_special_name(Blk->Spec))
    return TRUE;                /* destination can't be special file */
  else if(ParsePathAndName(Path, Name, Blk->Spec) != 2)
    {
    /* must be a proper name if it is the result curve block */
    error(ERROR_BAD_FILENAME, Blk->Spec);
    return TRUE;  /* flag error */
    }

  Blk->BlkIndex = GetCurveSetIndex(Name, Path, -1);
  return FALSE;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN CreateCorrexCurveset(SHORT * Points)
{
  ERR_OMA err;
  USHORT i;
  CURVEHDR *pCurvehdr;

  pCurvehdr = calloc(1, sizeof(CURVEHDR));
  if (pCurvehdr == NULL)
    {
    error(ERROR_ALLOC_MEM);
    return TRUE;
    }

  /* add curves as needed to the result curve block */
  for (i = 0; i < Corr.Count; i++)
    {
    if (err = ReadTempCurvehdr(&MainCurveDir, Lamp.BlkIndex, i, pCurvehdr))
      break;  /* if err, quit loop, free curvehdr, and return */

    if (*Points < (SHORT)pCurvehdr->pointnum)
      *Points = pCurvehdr->pointnum;
    pCurvehdr->DataType = FLOATTYPE;
    pCurvehdr->CurveCount = 1;
    pCurvehdr->MemData = FALSE;

    if (err= AddCurveSpaceToTempBlk(&MainCurveDir,
                                    Corr.BlkIndex, i, 1, pCurvehdr))
      break;  /* if err, quit loop, free curvehdr, and return */
    }
  free(pCurvehdr);
  return err != 0;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int CalcCorrexCurveset(void)
{
  SHORT Points = 0, SprefBuf = 0, DprefBuf = 1, i, j;
  FLOAT X, Y, CY, ExpTime;

  Corr.Start = Lamp.Start = MainCurveDir.Entries[Lamp.BlkIndex].StartIndex;
  Corr.Count = Lamp.Count = MainCurveDir.Entries[Lamp.BlkIndex].count;

  if(CreateCorrexCurveset(&Points))
    return FIELD_VALIDATE_WARNING;

  GetParam(DC_ET, &ExpTime);

  if (ExpTime == 0.0F)
    ExpTime = 1.0F;

  for (i = Lamp.Start; i < (const)(Lamp.Start + Lamp.Count); i++)
    {
    for (j = 0; j < Points; j++)
      {
      if (GetDataPoint(&MainCurveDir, Lamp.BlkIndex, i, j,
                       &X, &Y, FLOATTYPE, &SprefBuf))
        return FIELD_VALIDATE_WARNING;

      CY = point_interp(X);
      Y = CY / (Y / ExpTime);

      if(SetDataPoint(&MainCurveDir, Corr.BlkIndex, i, j, &X, &Y, 
                      FLOATTYPE, &DprefBuf))
        return FIELD_VALIDATE_WARNING;

      if (kbhit() && getch() == ESCAPE)
        return FIELD_VALIDATE_SUCCESS;
      }
    }
  return FIELD_VALIDATE_SUCCESS;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int do_gen_correx_curves(void)
{
  char Path[DOSPATHSIZE + 1] = "";
  char Name[DOSFILESIZE + 1] = "";
  SHORT Status = FIELD_VALIDATE_SUCCESS;
  WINDOW * MessageWindow;

  if (Lamp.BlkIndex == (USHORT)-1 || !total_pairs)
    return FIELD_VALIDATE_WARNING;

  if (CheckDestBlock(&Corr, Name, Path))
    return FIELD_VALIDATE_WARNING;

  if (Corr.BlkIndex != (USHORT)-1) /* put up overwrite warning */
    {
    if (yes_no_choice_window(BlkOverWritePrompt,0,COLORS_MESSAGE) != YES)
      return FIELD_VALIDATE_SUCCESS; /* return without error */

    if (DelTempFileBlk(&MainCurveDir, Corr.BlkIndex))
      return FIELD_VALIDATE_WARNING;
    }

  if (CreateTempFileBlk(&MainCurveDir, (SHORT*)&Corr.BlkIndex, Name,
                        Path, "", 0, 0L, 0, NULL, OMA4DATA, 0))
    return FIELD_VALIDATE_WARNING;

  put_up_message_window(BusyWorking, COLORS_MESSAGE, &MessageWindow);

  Status = CalcCorrexCurveset();

  MessageWindow = release_message_window(MessageWindow);
  MainCurveDir.Entries[Corr.BlkIndex].DisplayWindow |= (1 << CAL_PLOTBOX);
  return Status;
}

PRIVATE int gen_correx_curves(void * field_data, char * field_string)
{
  return do_gen_correx_curves();
}

// generate correction curve via macro language
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN GenCorrexCurve(char *LampName, char *CorrName)
{
  if (verify_lamp_curve(LampName, LampName) != FIELD_VALIDATE_SUCCESS)
    return FALSE;

  strcpy(Corr.Spec, CorrName);
  return (do_gen_correx_curves() == FIELD_VALIDATE_SUCCESS);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int ApplyCorrexToRealset(void)
{
  SHORT Points, SprefBuf = -1, DprefBuf = -1, i, j;
  FLOAT RealX, RealY, CorrX, CorrY, ExpTime;
  CURVEHDR CvHdr;

  memset(&CvHdr, 0, sizeof(CURVEHDR));

  Real.Start = Corr.Start = MainCurveDir.Entries[Real.BlkIndex].StartIndex;
  Real.Count = Corr.Count = MainCurveDir.Entries[Real.BlkIndex].count;

  GetParam(DC_ET, &ExpTime);

  if (ExpTime == 0.0F)
    ExpTime = 1.0F;

  for (i = Real.Start; i < (const)(Real.Start + Real.Count); i++)
    {
    if (ReadTempCurvehdr(&MainCurveDir, Real.BlkIndex, i, &CvHdr))
      break;  /* if err, quit loop and return */

    Points = CvHdr.pointnum;

    for (j = 0; j < Points; j++)
      {
      if (GetDataPoint(&MainCurveDir, Real.BlkIndex, i, j,
                       &RealX, &RealY, FLOATTYPE, &DprefBuf))
        return FIELD_VALIDATE_WARNING;

      if (GetDataPoint(&MainCurveDir, Corr.BlkIndex, i, j,
                       &CorrX, &CorrY, FLOATTYPE, &SprefBuf))
        return FIELD_VALIDATE_WARNING;

      RealY = (RealY / ExpTime) * CorrY;

      if(SetDataPoint(&MainCurveDir, Real.BlkIndex, i, j,
                      &RealX, &RealY, FLOATTYPE, &DprefBuf))
        return FIELD_VALIDATE_WARNING;

      if (kbhit() && getch() == ESCAPE)
        return FIELD_VALIDATE_SUCCESS;
      }
    }
  return FIELD_VALIDATE_SUCCESS;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int ycal_data_curves(void * field_data, char * field_string)
{
  char Path[DOSPATHSIZE + 1] = "";
  char Name[DOSFILESIZE + 1] = "";
  SHORT Status = FIELD_VALIDATE_SUCCESS;
  WINDOW * MessageWindow;

  if (Corr.BlkIndex == (USHORT)-1 || Real.BlkIndex == (USHORT)-1)
    return FIELD_VALIDATE_WARNING;

  if (CheckDestBlock(&Real, Name, Path))
    return FIELD_VALIDATE_WARNING;

  if (Real.BlkIndex != (USHORT)-1) /* put up overwrite warning */
    {
    if (yes_no_choice_window(BlkOverWritePrompt,0,COLORS_MESSAGE) != YES)
      return FIELD_VALIDATE_SUCCESS; /* return without error */
    }
  else
    {
    error(ERROR_CURVESET_NOT_FOUND, Real.Spec);
    return FIELD_VALIDATE_WARNING;
    }

  put_up_message_window(BusyWorking, COLORS_MESSAGE, &MessageWindow);

  Status = ApplyCorrexToRealset();

  MessageWindow = release_message_window(MessageWindow);
  MainCurveDir.Entries[Real.BlkIndex].DisplayWindow |= (1 << CAL_PLOTBOX);
  return Status;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int edit_ycalib_pair(void * field_data, char * field_string)
{
  SHORT index;
  FLOAT X, Y;

  delete_knot_at_x(knot_x_val(yknots_form.virtual_row_index));
  add_knot(X_knot, Y_knot);
  index = closest_knot(X_knot, &X, &Y);
  if (index != -1)
    redraw_scroll_form(&yknots_form, index, yknots_form.field_index);

  return FIELD_VALIDATE_SUCCESS;
}

// invoke graphics mode to allow user to specify manual knots.
// this is a select field function from the "Select Knots" field
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int do_ycalib_pair_add(void)
{
  total_pairs = current_knots();
  if (isYCalibForm())
    {
    display_random_field(&YCalibForm, FLD_KNOTS);
    redraw_scroll_form(&yknots_form, 0, FLD_XKNOT_SCR);
    ycalib_redraw(NULL, NULL);
    }
  return FIELD_VALIDATE_SUCCESS;
}

// invoke graphics mode to allow user to specify manual knots.
// this is a select field function from the "Select Knots" field
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int add_ycalib_pair(void * field_data, char * field_string)
{
  add_knot(0.0F, 0.0F);
  return do_ycalib_pair_add();
}

// Add a Wavelength, Relative intensity Value via the macro language 
// 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN AddYcalibPair(FLOAT Wlen, FLOAT Value)
{
  add_knot(Wlen, Value);
  return (do_ycalib_pair_add() == FIELD_VALIDATE_SUCCESS);
}

// select field function to delete a knot based on the scrolling knot form
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int do_ycalib_pair_delete(void)
{
  if (total_pairs == 0)     
    return 0;
  delete_knot_index(yknots_form.virtual_row_index);
  total_pairs = current_knots();
  if (isYCalibForm())
    {
    display_random_field(&YCalibForm, FLD_KNOTS);
    ycalib_redraw(NULL, NULL);
    }
  return FIELD_VALIDATE_SUCCESS;
}

// select field function to delete a knot based on the scrolling knot form
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE int delete_ycalib_pair(void * field_data, char * field_string)
{
  return do_ycalib_pair_delete();
}

// Delete a Wavelength, Relative intensity Value via the macro language 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN DeleteYCalibPair(SHORT index)
{
  yknots_form.virtual_row_index = index;
  return (do_ycalib_pair_delete() == FIELD_VALIDATE_SUCCESS);
}

// Macro routine to delete all the Ycalib pairs
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOLEAN DeleteLampData(void)
{
  delete_all_knots();
  total_pairs = 0;
  if (isYCalibForm())
    {
    display_random_field(&YCalibForm, FLD_KNOTS);
    ycalib_redraw(NULL, NULL);
    }
  return TRUE;
}

// get data function for use by generic_plot().  If the curve data is
// within Threshold of the baseline, plot zero.  Otherwise, plot
// the curve data less the baseline.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE ERR_OMA get_lampcurve_data(CURVEDIR *CurveDir,
                                         SHORT EntryIndex,
                                         USHORT CurveIndex , USHORT index,
                                         float * x_val, float * y_val,
                                         CHAR DataType, SHORT *PrefBuf)
{

  // first put the data point of the real curve in x_val, y_val
  ERR_OMA err  = GetDataPoint(CurveDir, EntryIndex, CurveIndex,
                                     index, x_val, y_val, DataType,
                                     PrefBuf);

  if(! err)
    {
    // put the y value of the baseline in YS
    float YS = point_interp(* x_val);

    * y_val -= YS;
    }
  return err;
}

// put a marker at each knot position for curve Z in the plot box
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE void draw_lampdata_markers(float Z)
{
  int i;
  CXY knot_point;
  CMARKERREPR MarkerRep, OldMarkerRep;

  // change the color and type of marker
  CInqMarkerRepr(screen_handle, &OldMarkerRep);

  MarkerRep.Type = CMK_Star;
  MarkerRep.Color = BRT_GREEN;
  MarkerRep.Height = KNOT_MARKER_HEIGHT;
  CSetMarkerRepr(screen_handle, &MarkerRep);

  for(i = 0; i < total_pairs; i ++)
    {
    knot_point = gss_position(&Plots[CAL_PLOTBOX], knot_x_val(i),
                              knot_y_val(i), Z);
    CPolymarker(screen_handle, 1, &knot_point);
    }
  // replace old marker style
  CSetMarkerRepr(screen_handle, &OldMarkerRep);       
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ERR_OMA ycalib_plot(float Z, USHORT Entry,
                           USHORT Curve, CURVEHDR * TCurveHdr)
{
  ERR_OMA err = ERROR_NONE;
  CRECT ClipRect;
  CRECT OldClipRect;

  // set the clipping rectangle and save the current one
  if(CalcClipRect(&Plots[CAL_PLOTBOX], Z, &ClipRect))
    return ERROR_NONE;
  CInqClipRectangle(deviceHandle(), &OldClipRect);
  CSetClipRectangle(deviceHandle(), ClipRect);
 
  SetGetFunction(get_lamp_data);
  err = array_plot(&Plots[CAL_PLOTBOX], &MainCurveDir, Entry, Curve, 0,
                   TCurveHdr->pointnum, Z);
  SetGetFunction(NULL);

  if (!err && Lamp.BlkIndex != (USHORT)-1)
    {
    err = array_plot(&Plots[CAL_PLOTBOX], &MainCurveDir, Entry, Curve, 0,
                     TCurveHdr->pointnum, Z);
    }

  if (!err)
    draw_lampdata_markers(Z);

  CSetClipRectangle(deviceHandle(), OldClipRect);
  return err;
}

// form init function for scrolling yknots_form
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE BOOLEAN yknots_form_init(int index)
{
  if((index >= current_knots()) || !current_knots) 
    return TRUE; // out of bounds

  X_knot = knot_x_val(index);
  Y_knot = knot_y_val(index);
  return FALSE;
}

// logic field function for use by scrolling knots form.  Used to determine
// whether the scrolling knots form is really being entered by the user and
// should retain the input focus or whether it should just be refreshed and
// not retain the input focus.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void registerYCalibForms(void)
{
  FormTable[KSI_YCAL_FORM] = &YCalibForm;
  FormTable[KSI_YKNOTS_FORM] = &yknots_form;
}
